package governance

struct ToolRegistration {
    toolName: Text,
    tag: Text
};

struct ToolConstraint {
    paramName: Text,
    operator: Text,
    values: List<Text>,
    description: Text
};

struct ToolConfig {
    toolName: Text,
    constraints: List<ToolConstraint>,
    requiresApproval: Boolean
};

struct PendingRequest {
    requestId: Text,
    toolName: Text,
    callerIdentity: Text,
    callerClaims: Map<Text, Text>,
    arguments: Text,
    sessionId: Text,
    requestPayload: Text,
    status: Text,
    reason: Text,
    decidedBy: Text,
    executionStatus: Text,
    executionResult: Text,
    createdAt: DateTime
};

struct EvaluationResult {
    decision: Text,
    requestId: Text,
    message: Text
};

@api
protocol[pAdmin, pGateway] ServiceGovernance() {
    initial state active;

    var serviceName: Text = "";
    private var tools: Map<Text, ToolRegistration> = mapOf<Text, ToolRegistration>();
    private var pendingRequests: Map<Text, PendingRequest> = mapOf<Text, PendingRequest>();
    private var requestIdToKey: Map<Text, Text> = mapOf<Text, Text>();
    private var requestCounter: Number = 0;
    private var toolConfigs: Map<Text, ToolConfig> = mapOf<Text, ToolConfig>();
    var approvalDeadlineHours: Number = 168;
    var governanceDescription: Text = "";

    @api
    permission[pAdmin] setup(name: Text) | active {
        require(serviceName == "", "Already initialized");
        serviceName = name;
        info("[ServiceGovernance] Initialized for service: " + name);
    };

    @api
    permission[pAdmin] registerTool(toolName: Text, tag: Text) | active {
        require(tag == "open" || tag == "gated", "Tag must be 'open' or 'gated'");
        var reg = ToolRegistration(toolName = toolName, tag = tag);
        tools = tools.with(toolName, reg);
    };

    @api
    permission[pAdmin] setTag(toolName: Text, tag: Text) | active {
        require(tag == "open" || tag == "gated", "Tag must be 'open' or 'gated'");
        require(tools.getOrNone(toolName).isPresent(), "Tool not found");
        var reg = ToolRegistration(toolName = toolName, tag = tag);
        tools = tools.with(toolName, reg);
    };

    // --- Constraint CRUD ---

    @api
    permission[pAdmin] addConstraint(
        toolName: Text,
        paramName: Text,
        operator: Text,
        values: List<Text>,
        description: Text
    ) | active {
        require(
            operator == "in" || operator == "not_in" || operator == "contains" ||
            operator == "not_contains" || operator == "regex" || operator == "max_length",
            "Operator must be one of: in, not_in, contains, not_contains, regex, max_length"
        );

        var constraint = ToolConstraint(
            paramName = paramName,
            operator = operator,
            values = values,
            description = description
        );

        var maybeConfig = toolConfigs.getOrNone(toolName);
        if (maybeConfig.isPresent()) {
            var existing = maybeConfig.getOrFail();
            // Remove any existing constraint for this param, then append new one
            var filtered = existing.constraints.filter(
                function(c: ToolConstraint) -> c.paramName != paramName || c.operator != operator
            );
            var updated = ToolConfig(
                toolName = toolName,
                constraints = filtered.with(constraint),
                requiresApproval = existing.requiresApproval
            );
            toolConfigs = toolConfigs.with(toolName, updated);
        } else {
            var newConfig = ToolConfig(
                toolName = toolName,
                constraints = listOf<ToolConstraint>(constraint),
                requiresApproval = true
            );
            toolConfigs = toolConfigs.with(toolName, newConfig);
        };
    };

    @api
    permission[pAdmin] removeConstraint(toolName: Text, paramName: Text) | active {
        var maybeConfig = toolConfigs.getOrNone(toolName);
        require(maybeConfig.isPresent(), "No config for tool");
        var existing = maybeConfig.getOrFail();
        var filtered = existing.constraints.filter(
            function(c: ToolConstraint) -> c.paramName != paramName
        );
        var updated = ToolConfig(
            toolName = toolName,
            constraints = filtered,
            requiresApproval = existing.requiresApproval
        );
        toolConfigs = toolConfigs.with(toolName, updated);
    };

    @api
    permission[pAdmin] clearConstraints(toolName: Text) | active {
        var maybeConfig = toolConfigs.getOrNone(toolName);
        if (maybeConfig.isPresent()) {
            var existing = maybeConfig.getOrFail();
            var updated = ToolConfig(
                toolName = toolName,
                constraints = listOf<ToolConstraint>(),
                requiresApproval = existing.requiresApproval
            );
            toolConfigs = toolConfigs.with(toolName, updated);
        };
    };

    // --- Tool governance config ---

    @api
    permission[pAdmin] setRequiresApproval(toolName: Text, required: Boolean) | active {
        var maybeConfig = toolConfigs.getOrNone(toolName);
        if (maybeConfig.isPresent()) {
            var existing = maybeConfig.getOrFail();
            var updated = ToolConfig(
                toolName = toolName,
                constraints = existing.constraints,
                requiresApproval = required
            );
            toolConfigs = toolConfigs.with(toolName, updated);
        } else {
            var newConfig = ToolConfig(
                toolName = toolName,
                constraints = listOf<ToolConstraint>(),
                requiresApproval = required
            );
            toolConfigs = toolConfigs.with(toolName, newConfig);
        };
    };

    // --- Service config ---

    @api
    permission[pAdmin] setApprovalDeadline(deadlineHours: Number) | active {
        require(deadlineHours > 0, "Deadline must be positive");
        approvalDeadlineHours = deadlineHours;
    };

    @api
    permission[pAdmin] setGovernanceDescription(desc: Text) | active {
        governanceDescription = desc;
    };

    // --- Read config (for governance-evaluator cache) ---

    @api
    permission[pGateway] getToolConfigs() returns List<ToolConfig> | active {
        return toolConfigs.values();
    };

    // --- Evaluate (updated with createdAt + auto-expire) ---

    @api
    permission[pGateway] evaluate(
        toolName: Text,
        callerIdentity: Text,
        callerClaims: Map<Text, Text>,
        arguments: Text,
        sessionId: Text,
        requestPayload: Text
    ) returns EvaluationResult | active {
        var lookupKey = callerIdentity + ":" + toolName + ":" + arguments;
        var maybeExisting = pendingRequests.getOrNone(lookupKey);

        if (maybeExisting.isPresent()) {
            var existing = maybeExisting.getOrFail();

            // Auto-expire: if deadline has passed, remove and recreate
            if (existing.status == "pending" && existing.createdAt.plus(hours(approvalDeadlineHours)).isBefore(now(), false)) {
                pendingRequests = pendingRequests.without(lookupKey);
                requestIdToKey = requestIdToKey.without(existing.requestId);
                // Fall through to create new request
            } else {
                if (existing.status == "approved") {
                    pendingRequests = pendingRequests.without(lookupKey);
                    requestIdToKey = requestIdToKey.without(existing.requestId);
                    return EvaluationResult(decision = "allow", requestId = existing.requestId, message = "Approved");
                };

                if (existing.status == "denied") {
                    var denyReason = existing.reason;
                    pendingRequests = pendingRequests.without(lookupKey);
                    requestIdToKey = requestIdToKey.without(existing.requestId);
                    return EvaluationResult(decision = "deny", requestId = existing.requestId, message = denyReason);
                };

                return EvaluationResult(
                    decision = "pending",
                    requestId = existing.requestId,
                    message = "Awaiting approval"
                );
            };
        };

        requestCounter = requestCounter + 1;
        var requestId = "REQ-" + requestCounter.toText();

        var pending = PendingRequest(
            requestId = requestId,
            toolName = toolName,
            callerIdentity = callerIdentity,
            callerClaims = callerClaims,
            arguments = arguments,
            sessionId = sessionId,
            requestPayload = requestPayload,
            status = "pending",
            reason = "",
            decidedBy = "",
            executionStatus = "none",
            executionResult = "",
            createdAt = now()
        );

        pendingRequests = pendingRequests.with(lookupKey, pending);
        requestIdToKey = requestIdToKey.with(requestId, lookupKey);

        return EvaluationResult(
            decision = "pending",
            requestId = requestId,
            message = "Awaiting approval"
        );
    };

    @api
    permission[pAdmin] approve(requestId: Text) | active {
        var maybeLookupKey = requestIdToKey.getOrNone(requestId);
        require(maybeLookupKey.isPresent(), "Request not found");
        var lookupKey = maybeLookupKey.getOrFail();

        var existing = pendingRequests.getOrNone(lookupKey).getOrFail();
        require(existing.status == "pending", "Request is not pending");

        var updated = PendingRequest(
            requestId = existing.requestId,
            toolName = existing.toolName,
            callerIdentity = existing.callerIdentity,
            callerClaims = existing.callerClaims,
            arguments = existing.arguments,
            sessionId = existing.sessionId,
            requestPayload = existing.requestPayload,
            status = "approved",
            reason = "",
            decidedBy = "admin",
            executionStatus = "queued",
            executionResult = existing.executionResult,
            createdAt = existing.createdAt
        );

        pendingRequests = pendingRequests.with(lookupKey, updated);
    };

    @api
    permission[pAdmin] deny(requestId: Text, reason: Text) | active {
        var maybeLookupKey = requestIdToKey.getOrNone(requestId);
        require(maybeLookupKey.isPresent(), "Request not found");
        var lookupKey = maybeLookupKey.getOrFail();

        var existing = pendingRequests.getOrNone(lookupKey).getOrFail();
        require(existing.status == "pending", "Request is not pending");

        var updated = PendingRequest(
            requestId = existing.requestId,
            toolName = existing.toolName,
            callerIdentity = existing.callerIdentity,
            callerClaims = existing.callerClaims,
            arguments = existing.arguments,
            sessionId = existing.sessionId,
            requestPayload = existing.requestPayload,
            status = "denied",
            reason = reason,
            decidedBy = "admin",
            executionStatus = "none",
            executionResult = existing.executionResult,
            createdAt = existing.createdAt
        );

        pendingRequests = pendingRequests.with(lookupKey, updated);
    };

    @api
    permission[pAdmin] getPendingRequests() returns List<PendingRequest> | active {
        var allValues = pendingRequests.values();
        return allValues.filter(function(req: PendingRequest) -> req.status == "pending");
    };
}
