package policies

/**
 * A flow rule defining a blocked sequence: if source was called
 * earlier in the session, target is blocked.
 *
 * @param sourceService  Service name of the source call
 * @param sourceTool     Tool name of the source call
 * @param targetService  Service name of the blocked target call
 * @param targetTool     Tool name of the blocked target call
 * @param description    Human-readable description
 */
struct FlowRule {
    sourceService: Text,
    sourceTool: Text,
    targetService: Text,
    targetTool: Text,
    description: Text
};

/**
 * A recorded tool call within a session.
 *
 * @param sessionId       MCP session ID
 * @param serviceName     MCP service name
 * @param toolName        Tool name
 * @param verb            Classified verb
 * @param labels          Comma-separated labels (stored for audit)
 * @param callerIdentity  Authenticated user identity
 */
struct CallRecord {
    sessionId: Text,
    serviceName: Text,
    toolName: Text,
    verb: Text,
    labels: Text,
    callerIdentity: Text
};

/**
 * FlowPolicy — cross-call data flow governance within sessions.
 *
 * A contextual routing protocol (Layer 2) that tracks tool call sequences
 * per MCP session and enforces flow rules. Prevents dangerous sequences
 * like reading sensitive data then sending it externally.
 *
 * Use cases:
 *   - PII exfiltration prevention: read customer data → block send email
 *   - Data sovereignty: access EU data → block non-EU storage
 *   - Workflow ordering: require read before write
 *
 * Flow:
 *   1. OPA classifies tool call → security policy says "npl_evaluate"
 *   2. OPA calls evaluate() with MCP session ID (Layer 2)
 *   3. FlowPolicy checks session history against flow rules
 *   4. Records the call, returns "allow" or "deny"
 *
 * No matching rules = no flow constraints (always "allow").
 * Empty session ID = no session tracking, flow rules not enforced.
 *
 * @party pAdmin    Organization administrator (manages flow rules, views history)
 * @party pGateway  MCP Gateway (calls evaluate at request time)
 */
@api
protocol[pAdmin, pGateway] FlowPolicy() {
    initial state active;

    private var flowRules: List<FlowRule> = listOf<FlowRule>();
    private var sessionHistory: Map<Text, List<CallRecord>> = mapOf<Text, List<CallRecord>>();
    private var totalEvaluations: Number = 0;
    private var totalDenied: Number = 0;

    // ========================================================================
    // Gateway evaluation (called by OPA Layer 2)
    // ========================================================================

    /**
     * Evaluate a tool call against flow rules within the current session.
     *
     * Returns:
     *   "allow" — no flow violation detected (or no rules match, or no session)
     *   "deny"  — flow rule violated (source was called earlier in session)
     *
     * @param toolName        Tool being called
     * @param callerIdentity  Authenticated user identity
     * @param sessionId       MCP session ID (required for flow tracking)
     * @param verb            Classified verb
     * @param labels          Comma-separated labels (stored for audit)
     * @param annotations     Comma-separated hints (reserved)
     * @param argumentDigest  SHA-256 of tool arguments (reserved)
     * @param approvers       Required approver roles (reserved)
     * @param requestPayload  Serialized JSON-RPC body (reserved)
     * @param serviceName     Resolved MCP service name
     */
    @api
    permission[pGateway] evaluate(
        toolName: Text,
        callerIdentity: Text,
        sessionId: Text,
        verb: Text,
        labels: Text,
        annotations: Text,
        argumentDigest: Text,
        approvers: List<Text>,
        requestPayload: Text,
        serviceName: Text
    ) returns Text | active {
        totalEvaluations = totalEvaluations + 1;

        // No session ID = can't track flow, allow
        if (sessionId == "") {
            return "allow";
        };

        // Get rules targeting the current call
        var targetKey = serviceName + ":" + toolName;
        var targetRules = flowRules.filter(function(rule: FlowRule) ->
            rule.targetService + ":" + rule.targetTool == targetKey
        );

        // No rules targeting this call = no flow constraints
        if (targetRules.size() == 0) {
            // Record call and allow
            var record = CallRecord(
                sessionId = sessionId,
                serviceName = serviceName,
                toolName = toolName,
                verb = verb,
                labels = labels,
                callerIdentity = callerIdentity
            );
            var maybeHistory = sessionHistory.getOrNone(sessionId);
            var history = listOf<CallRecord>();
            if (maybeHistory.isPresent()) {
                history = maybeHistory.getOrFail();
            };
            sessionHistory = sessionHistory.with(sessionId, history.with(record));
            return "allow";
        };

        // Get session history
        var maybeHistory = sessionHistory.getOrNone(sessionId);
        var history = listOf<CallRecord>();
        if (maybeHistory.isPresent()) {
            history = maybeHistory.getOrFail();
        };

        // Check each target rule: is the source in session history?
        // Use findFirstOrNone to find the first violated rule
        var violation = targetRules.findFirstOrNone(function(rule: FlowRule) ->
            history.findFirstOrNone(function(rec: CallRecord) ->
                rec.serviceName + ":" + rec.toolName == rule.sourceService + ":" + rule.sourceTool
            ).isPresent()
        );

        // Record current call regardless of outcome (for future rule checks)
        var record = CallRecord(
            sessionId = sessionId,
            serviceName = serviceName,
            toolName = toolName,
            verb = verb,
            labels = labels,
            callerIdentity = callerIdentity
        );
        sessionHistory = sessionHistory.with(sessionId, history.with(record));

        if (violation.isPresent()) {
            totalDenied = totalDenied + 1;
            var violatedRule = violation.getOrFail();
            info("[FlowPolicy] Deny " + callerIdentity + " -> " + serviceName + "." + toolName + " (flow rule: " + violatedRule.sourceService + "." + violatedRule.sourceTool + " was called earlier in session " + sessionId + ")");
            return "deny";
        };

        info("[FlowPolicy] Allow " + callerIdentity + " -> " + serviceName + "." + toolName + " (session " + sessionId + ")");
        return "allow";
    };

    // ========================================================================
    // Admin: flow rule management
    // ========================================================================

    /**
     * Add a flow rule: after source is called in a session, target is blocked.
     */
    @api
    permission[pAdmin] setFlowRule(sourceService: Text, sourceTool: Text, targetService: Text, targetTool: Text, description: Text) | active {
        var newRule = FlowRule(
            sourceService = sourceService,
            sourceTool = sourceTool,
            targetService = targetService,
            targetTool = targetTool,
            description = description
        );
        // Remove existing rule with same source→target if any
        var maybeExisting = flowRules.findFirstOrNone(function(r: FlowRule) ->
            r.sourceService == sourceService && r.sourceTool == sourceTool
            && r.targetService == targetService && r.targetTool == targetTool
        );
        if (maybeExisting.isPresent()) {
            flowRules = flowRules.without(maybeExisting.getOrFail()).with(newRule);
        } else {
            flowRules = flowRules.with(newRule);
        };
        info("[FlowPolicy] Set flow rule: " + sourceService + "." + sourceTool + " -> " + targetService + "." + targetTool + " = deny");
    };

    /**
     * Remove a flow rule.
     */
    @api
    permission[pAdmin] removeFlowRule(sourceService: Text, sourceTool: Text, targetService: Text, targetTool: Text) | active {
        var maybeExisting = flowRules.findFirstOrNone(function(r: FlowRule) ->
            r.sourceService == sourceService && r.sourceTool == sourceTool
            && r.targetService == targetService && r.targetTool == targetTool
        );
        if (maybeExisting.isPresent()) {
            flowRules = flowRules.without(maybeExisting.getOrFail());
        };
        info("[FlowPolicy] Removed flow rule: " + sourceService + "." + sourceTool + " -> " + targetService + "." + targetTool);
    };

    /**
     * Get all flow rules.
     */
    @api
    permission[pAdmin] getFlowRules() returns List<FlowRule> | active {
        return flowRules;
    };

    // ========================================================================
    // Admin: session history
    // ========================================================================

    /**
     * Get call history for a specific session.
     */
    @api
    permission[pAdmin] getSessionHistory(sessionId: Text) returns List<CallRecord> | active {
        var maybeHistory = sessionHistory.getOrNone(sessionId);
        if (maybeHistory.isPresent()) {
            return maybeHistory.getOrFail();
        };
        return listOf<CallRecord>();
    };

    /**
     * Clear history for a specific session.
     */
    @api
    permission[pAdmin] clearSessionHistory(sessionId: Text) | active {
        sessionHistory = sessionHistory.without(sessionId);
        info("[FlowPolicy] Cleared session history: " + sessionId);
    };

    /**
     * Clear all session history.
     */
    @api
    permission[pAdmin] clearAllHistory() | active {
        sessionHistory = mapOf<Text, List<CallRecord>>();
        info("[FlowPolicy] Cleared all session history");
    };

    // ========================================================================
    // Admin: statistics
    // ========================================================================

    /**
     * Get summary statistics.
     */
    @api
    permission[pAdmin] getStatistics() returns Text | active {
        return "evaluations=" + totalEvaluations.toText()
            + ",denied=" + totalDenied.toText()
            + ",flowRules=" + flowRules.size().toText()
            + ",activeSessions=" + sessionHistory.size().toText();
    };
}
