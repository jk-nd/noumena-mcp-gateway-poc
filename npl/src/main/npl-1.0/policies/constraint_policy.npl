package policies

/**
 * A constraint rule limiting calls to a specific service+tool per caller.
 *
 * @param serviceName   MCP service name (e.g., "banking")
 * @param toolName      Tool name (e.g., "transfer")
 * @param maxOccurrences Maximum allowed calls per caller (0 = always deny)
 * @param description   Human-readable description of the constraint
 */
struct ConstraintRule {
    serviceName: Text,
    toolName: Text,
    maxOccurrences: Number,
    description: Text
};

/**
 * Per-caller usage counter for a specific constraint.
 *
 * @param callerIdentity Authenticated user identity
 * @param serviceName    MCP service name
 * @param toolName       Tool name
 * @param callCount      Number of calls made
 */
struct ConstraintCounter {
    callerIdentity: Text,
    serviceName: Text,
    toolName: Text,
    callCount: Number
};

/**
 * ConstraintPolicy — stateful argument/call constraints for tool calls.
 *
 * A contextual routing protocol (Layer 2) that enforces per-caller budgets
 * on specific tool calls. Unlike RateLimitPolicy (per-service), ConstraintPolicy
 * operates at tool-level granularity with configurable occurrence limits.
 *
 * Design note: OPA Layer 1 handles stateless value-based constraints
 * (greater_than, less_than via classifiers). ConstraintPolicy handles stateful
 * cross-call constraints: "allow max N calls to service.tool per caller".
 *
 * Flow:
 *   1. OPA classifies tool call → security policy says "npl_evaluate"
 *   2. OPA calls evaluate() via contextual route (Layer 2)
 *   3. ConstraintPolicy checks call count vs configured limit
 *   4. Returns "allow" (under limit) or "deny" (at/over limit) immediately
 *
 * No constraint configured for a service+tool = unconstrained (always "allow").
 *
 * @party pAdmin    Organization administrator (manages constraints, views usage)
 * @party pGateway  MCP Gateway (calls evaluate at request time)
 */
@api
protocol[pAdmin, pGateway] ConstraintPolicy() {
    initial state active;

    private var constraints: List<ConstraintRule> = listOf<ConstraintRule>();
    private var counters: List<ConstraintCounter> = listOf<ConstraintCounter>();
    private var totalEvaluations: Number = 0;
    private var totalDenied: Number = 0;

    // ========================================================================
    // Gateway evaluation (called by OPA Layer 2)
    // ========================================================================

    /**
     * Evaluate a tool call against constraint rules.
     *
     * Returns:
     *   "allow" — under limit (or no constraint configured)
     *   "deny"  — at or over limit, or maxOccurrences is 0 (blocked)
     *
     * @param toolName        Tool being called
     * @param callerIdentity  Authenticated user identity
     * @param sessionId       MCP session ID (reserved)
     * @param verb            Classified verb (reserved)
     * @param labels          Comma-separated labels (reserved)
     * @param annotations     Comma-separated hints (reserved)
     * @param argumentDigest  SHA-256 of tool arguments (reserved)
     * @param approvers       Required approver roles (reserved)
     * @param requestPayload  Serialized JSON-RPC body (reserved)
     * @param serviceName     Resolved MCP service name
     */
    @api
    permission[pGateway] evaluate(
        toolName: Text,
        callerIdentity: Text,
        sessionId: Text,
        verb: Text,
        labels: Text,
        annotations: Text,
        argumentDigest: Text,
        approvers: List<Text>,
        requestPayload: Text,
        serviceName: Text
    ) returns Text | active {
        totalEvaluations = totalEvaluations + 1;

        // Find constraint for this service+tool
        var maybeConstraint = constraints.findFirstOrNone(
            function(c: ConstraintRule) -> c.serviceName == serviceName && c.toolName == toolName
        );

        // No constraint configured = unconstrained
        if (!maybeConstraint.isPresent()) {
            return "allow";
        };

        var constraint = maybeConstraint.getOrFail();

        // maxOccurrences == 0 means always deny (blocked tool)
        if (constraint.maxOccurrences == 0) {
            totalDenied = totalDenied + 1;
            info("[ConstraintPolicy] Deny (blocked) " + callerIdentity + " -> " + serviceName + "." + toolName);
            return "deny";
        };

        // Find or check usage counter
        var maybeCounter = counters.findFirstOrNone(
            function(ct: ConstraintCounter) -> ct.callerIdentity == callerIdentity && ct.serviceName == serviceName && ct.toolName == toolName
        );

        var currentCount = 0;
        if (maybeCounter.isPresent()) {
            currentCount = maybeCounter.getOrFail().callCount;
        };

        if (currentCount < constraint.maxOccurrences) {
            // Under limit — increment and allow
            var newCounter = ConstraintCounter(
                callerIdentity = callerIdentity,
                serviceName = serviceName,
                toolName = toolName,
                callCount = currentCount + 1
            );
            if (maybeCounter.isPresent()) {
                counters = counters.without(maybeCounter.getOrFail()).with(newCounter);
            } else {
                counters = counters.with(newCounter);
            };
            info("[ConstraintPolicy] Allow " + callerIdentity + " -> " + serviceName + "." + toolName + " (" + (currentCount + 1).toText() + "/" + constraint.maxOccurrences.toText() + ")");
            return "allow";
        };

        // At or over limit — deny
        totalDenied = totalDenied + 1;
        info("[ConstraintPolicy] Deny " + callerIdentity + " -> " + serviceName + "." + toolName + " (" + currentCount.toText() + "/" + constraint.maxOccurrences.toText() + " limit reached)");
        return "deny";
    };

    // ========================================================================
    // Admin: constraint management
    // ========================================================================

    /**
     * Set or update a constraint rule for a service+tool.
     */
    @api
    permission[pAdmin] setConstraint(serviceName: Text, toolName: Text, maxOccurrences: Number, description: Text) | active {
        var maybeExisting = constraints.findFirstOrNone(
            function(c: ConstraintRule) -> c.serviceName == serviceName && c.toolName == toolName
        );
        var newConstraint = ConstraintRule(
            serviceName = serviceName,
            toolName = toolName,
            maxOccurrences = maxOccurrences,
            description = description
        );
        if (maybeExisting.isPresent()) {
            constraints = constraints.without(maybeExisting.getOrFail()).with(newConstraint);
        } else {
            constraints = constraints.with(newConstraint);
        };
        info("[ConstraintPolicy] Set constraint: " + serviceName + "." + toolName + " -> max " + maxOccurrences.toText());
    };

    /**
     * Remove a constraint rule.
     */
    @api
    permission[pAdmin] removeConstraint(serviceName: Text, toolName: Text) | active {
        var maybeExisting = constraints.findFirstOrNone(
            function(c: ConstraintRule) -> c.serviceName == serviceName && c.toolName == toolName
        );
        if (maybeExisting.isPresent()) {
            constraints = constraints.without(maybeExisting.getOrFail());
        };
        info("[ConstraintPolicy] Removed constraint: " + serviceName + "." + toolName);
    };

    /**
     * Get all configured constraints.
     */
    @api
    permission[pAdmin] getConstraints() returns List<ConstraintRule> | active {
        return constraints;
    };

    // ========================================================================
    // Admin: usage queries
    // ========================================================================

    /**
     * Get all usage counters.
     */
    @api
    permission[pAdmin] getAllCounters() returns List<ConstraintCounter> | active {
        return counters;
    };

    /**
     * Reset usage counter for a specific caller+service+tool.
     */
    @api
    permission[pAdmin] resetCounter(callerIdentity: Text, serviceName: Text, toolName: Text) | active {
        var maybeCounter = counters.findFirstOrNone(
            function(ct: ConstraintCounter) -> ct.callerIdentity == callerIdentity && ct.serviceName == serviceName && ct.toolName == toolName
        );
        if (maybeCounter.isPresent()) {
            counters = counters.without(maybeCounter.getOrFail());
        };
        info("[ConstraintPolicy] Reset counter: " + callerIdentity + " -> " + serviceName + "." + toolName);
    };

    /**
     * Reset all usage counters.
     */
    @api
    permission[pAdmin] resetAllCounters() | active {
        counters = listOf<ConstraintCounter>();
        info("[ConstraintPolicy] Reset all counters");
    };

    // ========================================================================
    // Admin: statistics
    // ========================================================================

    /**
     * Get summary statistics.
     */
    @api
    permission[pAdmin] getStatistics() returns Text | active {
        return "evaluations=" + totalEvaluations.toText()
            + ",denied=" + totalDenied.toText()
            + ",constraints=" + constraints.size().toText()
            + ",activeCounters=" + counters.size().toText();
    };
}
