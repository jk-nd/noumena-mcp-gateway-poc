package policies

/**
 * Rule for selecting which credential to use based on request context.
 * 
 * @param credentialName Name of credential to use (e.g., "work_account", "personal_account")
 * @param condition NPL expression evaluated against request context
 * @param priority Higher priority rules evaluated first (10 = high, 1 = low)
 */
struct InjectionRule {
    credentialName: Text,
    condition: Text,
    priority: Number
};

/**
 * Result of credential selection.
 * IMPORTANT: Does NOT contain actual secrets, only metadata!
 * 
 * @param credentialName Name of selected credential (e.g., "work_account")
 * @param serviceName Service this credential is for (e.g., "github")
 */
struct CredentialSelection {
    credentialName: Text,
    serviceName: Text
};

/**
 * CredentialInjectionPolicy - Determines WHICH credential to use for requests.
 * 
 * SECURITY: This protocol NEVER handles actual secrets!
 * It only returns credential NAMES. The Vault Sidecar fetches actual secrets.
 * 
 * Flow:
 * 1. Admin registers rules: "For github + acme repos â†’ use work_account"
 * 2. Gateway asks: "Which credential for this request?"
 * 3. Policy evaluates rules and returns credential NAME
 * 4. Vault Sidecar uses name to fetch actual secrets from Vault
 * 
 * Rules support conditions like:
 * - "operation == 'create_issue'"
 * - "metadata.repo startsWith 'acme/'"
 * - "metadata.environment == 'production'"
 * - "true" (default/fallback rule)
 * 
 * @party pAdmin Organization administrator who manages credential rules
 * @party pGateway MCP Gateway requesting credential selection
 * @party pAuditor Read-only access for security auditing
 */
@api
protocol[pAdmin, pGateway, pAuditor] CredentialInjectionPolicy() {
    initial state ready;
    final state suspended;
    
    // Maps: serviceName -> list of injection rules (sorted by priority)
    private var injectionRules: Map<Text, List<InjectionRule>> = mapOf<Text, List<InjectionRule>>();
    
    // Counter for tracking number of credential selections
    private var selectionCounter: Number = 0;
    
    /**
     * Admin suspends all credential injection (emergency stop).
     */
    @api
    permission[pAdmin] suspendPolicy() | ready {
        become suspended;
    };
    
    /**
     * Admin adds or updates a credential injection rule.
     * 
     * Example rules:
     * 
     * // Use work GitHub for company repos
     * addInjectionRule(
     *   service: "github",
     *   credentialName: "work_account",
     *   condition: "metadata.repo startsWith 'acme/'",
     *   priority: 10
     * )
     * 
     * // Use personal GitHub as fallback
     * addInjectionRule(
     *   service: "github",
     *   credentialName: "personal_account",
     *   condition: "true",
     *   priority: 1
     * )
     * 
     * // Use prod Slack for alerts
     * addInjectionRule(
     *   service: "slack",
     *   credentialName: "prod_workspace",
     *   condition: "metadata.channel == '#alerts'",
     *   priority: 10
     * )
     * 
     * @param serviceName Target service (e.g., "github", "slack")
     * @param credentialName Name of credential to use (e.g., "work_account")
     * @param condition NPL expression for when to use this credential
     * @param priority Higher priority rules evaluated first (10 = high, 1 = low)
     */
    @api
    permission[pAdmin] addInjectionRule(
        serviceName: Text,
        credentialName: Text,
        condition: Text,
        priority: Number
    ) | ready {
        var rule = InjectionRule(
            credentialName = credentialName,
            condition = condition,
            priority = priority
        );
        
        // Get existing rules for this service
        var maybeRules = injectionRules.getOrNone(serviceName);
        var existingRules = if (maybeRules.isPresent()) {
            maybeRules.getOrFail()
        } else {
            listOf<InjectionRule>()
        };
        
        // Add new rule
        var updatedRules = existingRules.with(rule);
        
        injectionRules = injectionRules.with(serviceName, updatedRules);
        
        info("[CredentialInjectionPolicy] Rule added: " + serviceName + " -> " + credentialName + " (priority " + priority.toText() + ")");
    };
    
    /**
     * Admin removes a credential injection rule.
     * 
     * @param serviceName Service to remove rule from
     * @param credentialName Credential name to remove
     */
    @api
    permission[pAdmin] removeInjectionRule(
        serviceName: Text,
        credentialName: Text
    ) | ready {
        var maybeRules = injectionRules.getOrNone(serviceName);
        
        if (maybeRules.isPresent()) {
            var rules = maybeRules.getOrFail();
            // Filter out rules matching the credential name
            var filteredRules = rules.filter(function(r: InjectionRule) -> r.credentialName != credentialName);
            
            if (filteredRules.size() > 0) {
                injectionRules = injectionRules.with(serviceName, filteredRules);
            } else {
                injectionRules = injectionRules.without(serviceName);
            };
            
            info("[CredentialInjectionPolicy] Rule removed: " + serviceName + " -> " + credentialName);
        };
    };
    
    /**
     * Gateway requests credential selection for a request.
     * Returns the NAME of the credential to use (NOT actual secrets!).
     * 
     * Process:
     * 1. Look up rules for service
     * 2. Evaluate rules in priority order (high to low)
     * 3. Return first matching rule's credential name
     * 4. If no match, return default credential name
     * 
     * @param serviceName Target service (e.g., "github")
     * @param operationName Operation being performed (e.g., "create_issue")
     * @param requestMetadata Request context for rule evaluation (e.g., {"repo": "acme/foo"})
     * @return Credential name to use (e.g., "work_account")
     */
    @api
    permission[pGateway] selectCredential(
        serviceName: Text,
        operationName: Text,
        requestMetadata: Map<Text, Text>
    ) returns CredentialSelection | ready {
        selectionCounter = selectionCounter + 1;
        
        // Get rules for this service
        var maybeRules = injectionRules.getOrNone(serviceName);
        
        var selectedName = if (maybeRules.isPresent()) {
            var rules = maybeRules.getOrFail();
            
            // TODO: Sort rules by priority and evaluate conditions
            // For now, return first rule's credential as a simple implementation
            // In full implementation, evaluate condition expressions and find max priority
            
            if (rules.size() > 0) {
                // Simple implementation: use first rule
                // TODO: Find rule with highest priority (NPL doesn't support while loops)
                // TODO: Evaluate rule.condition against (operationName, requestMetadata)
                var firstRule = rules.get(0);
                firstRule.credentialName
            } else {
                "default"
            }
        } else {
            "default"
        };
        
        info("[CredentialInjectionPolicy] Selected credential for " + serviceName + "." + operationName + ": " + selectedName);
        
        return CredentialSelection(
            credentialName = selectedName,
            serviceName = serviceName
        );
    };
    
    /**
     * Get all rules for a service (for admin/audit purposes).
     * 
     * @param serviceName Service to get rules for
     * @return List of rules as JSON text
     */
    @api
    permission[pAdmin | pAuditor] getRulesForService(serviceName: Text) returns Text | ready, suspended {
        var maybeRules = injectionRules.getOrNone(serviceName);
        
        if (maybeRules.isPresent()) {
            var rules = maybeRules.getOrFail();
            // TODO: Convert to JSON - for now return count
            return "Rules for " + serviceName + ": " + rules.size().toText() + " rules";
        } else {
            return "No rules for " + serviceName;
        };
    };
    
    /**
     * Get statistics about credential selections.
     * 
     * @return Statistics as text
     */
    @api
    permission[pAdmin | pAuditor] getStatistics() returns Text | ready, suspended {
        var serviceCount = injectionRules.size();
        return "Services with rules: " + serviceCount.toText() + ", Total selections: " + selectionCounter.toText();
    };
}
