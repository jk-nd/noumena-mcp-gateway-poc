package policies

/**
 * A precondition rule that gates tool calls on a named system condition.
 *
 * @param conditionName   Name of the condition to check (e.g., "maintenance_mode")
 * @param requiredValue   Value the condition must have for the call to proceed (e.g., "false")
 * @param serviceName     MCP service name this rule applies to
 * @param toolName        Tool name this rule applies to
 */
struct PreconditionRule {
    conditionName: Text,
    requiredValue: Text,
    serviceName: Text,
    toolName: Text
};

/**
 * PreconditionPolicy — system state flags that gate tool calls.
 *
 * A contextual routing protocol (Layer 2) that checks named conditions
 * (system state flags) before allowing tool calls. Returns "allow" only
 * when ALL matching precondition rules are satisfied.
 *
 * Use cases:
 *   - Maintenance mode: block all writes during maintenance
 *   - Trading hours: only allow trading during market hours
 *   - Feature flags: enable/disable specific tool capabilities
 *   - Operational readiness: require all systems "green" before actions
 *
 * Flow:
 *   1. OPA classifies tool call → security policy says "npl_evaluate"
 *   2. OPA calls evaluate() via contextual route (Layer 2)
 *   3. PreconditionPolicy checks all matching rules against conditions
 *   4. Returns "allow" (all conditions met) or "deny" (any condition unmet)
 *
 * No matching rules for a service+tool = no preconditions (always "allow").
 *
 * @party pAdmin    Organization administrator (manages conditions and rules)
 * @party pGateway  MCP Gateway (calls evaluate at request time)
 */
@api
protocol[pAdmin, pGateway] PreconditionPolicy() {
    initial state active;

    private var conditions: Map<Text, Text> = mapOf<Text, Text>();
    private var rules: List<PreconditionRule> = listOf<PreconditionRule>();
    private var totalEvaluations: Number = 0;
    private var totalDenied: Number = 0;

    // ========================================================================
    // Gateway evaluation (called by OPA Layer 2)
    // ========================================================================

    /**
     * Evaluate a tool call against precondition rules.
     *
     * Returns:
     *   "allow" — all matching preconditions satisfied (or no rules match)
     *   "deny"  — one or more preconditions not met
     *
     * @param toolName        Tool being called
     * @param callerIdentity  Authenticated user identity
     * @param sessionId       MCP session ID (reserved)
     * @param verb            Classified verb (reserved)
     * @param labels          Comma-separated labels (reserved)
     * @param annotations     Comma-separated hints (reserved)
     * @param argumentDigest  SHA-256 of tool arguments (reserved)
     * @param approvers       Required approver roles (reserved)
     * @param requestPayload  Serialized JSON-RPC body (reserved)
     * @param serviceName     Resolved MCP service name
     */
    @api
    permission[pGateway] evaluate(
        toolName: Text,
        callerIdentity: Text,
        sessionId: Text,
        verb: Text,
        labels: Text,
        annotations: Text,
        argumentDigest: Text,
        approvers: List<Text>,
        requestPayload: Text,
        serviceName: Text
    ) returns Text | active {
        totalEvaluations = totalEvaluations + 1;

        // Find rules matching this service+tool
        var matchingRules = rules.filter(
            function(r: PreconditionRule) -> r.serviceName == serviceName && r.toolName == toolName
        );

        // No matching rules = no preconditions, allow
        if (matchingRules.size() == 0) {
            return "allow";
        };

        // Check all matching rules — all must be satisfied
        var failedRules = matchingRules.filter(function(r: PreconditionRule) ->
            // Rule fails if condition is missing or has wrong value
            !(conditions.getOrNone(r.conditionName).isPresent())
            || conditions.getOrNone(r.conditionName).getOrFail() != r.requiredValue
        );

        if (failedRules.size() > 0) {
            totalDenied = totalDenied + 1;
            var firstFailed = failedRules.get(0);
            info("[PreconditionPolicy] Deny " + callerIdentity + " -> " + serviceName + "." + toolName + " (condition " + firstFailed.conditionName + " not met)");
            return "deny";
        };

        info("[PreconditionPolicy] Allow " + callerIdentity + " -> " + serviceName + "." + toolName + " (all " + matchingRules.size().toText() + " preconditions met)");
        return "allow";
    };

    // ========================================================================
    // Admin: condition management
    // ========================================================================

    /**
     * Set a system condition value.
     */
    @api
    permission[pAdmin] setCondition(conditionName: Text, value: Text) | active {
        conditions = conditions.with(conditionName, value);
        info("[PreconditionPolicy] Set condition: " + conditionName + " = " + value);
    };

    /**
     * Remove a system condition.
     */
    @api
    permission[pAdmin] removeCondition(conditionName: Text) | active {
        conditions = conditions.without(conditionName);
        info("[PreconditionPolicy] Removed condition: " + conditionName);
    };

    /**
     * Get all current conditions.
     */
    @api
    permission[pAdmin] getConditions() returns Map<Text, Text> | active {
        return conditions;
    };

    // ========================================================================
    // Admin: rule management
    // ========================================================================

    /**
     * Add a precondition rule.
     */
    @api
    permission[pAdmin] addRule(conditionName: Text, requiredValue: Text, serviceName: Text, toolName: Text) | active {
        var newRule = PreconditionRule(
            conditionName = conditionName,
            requiredValue = requiredValue,
            serviceName = serviceName,
            toolName = toolName
        );
        rules = rules.with(newRule);
        info("[PreconditionPolicy] Added rule: " + serviceName + "." + toolName + " requires " + conditionName + " == " + requiredValue);
    };

    /**
     * Remove a precondition rule.
     */
    @api
    permission[pAdmin] removeRule(conditionName: Text, serviceName: Text, toolName: Text) | active {
        var maybeExisting = rules.findFirstOrNone(
            function(r: PreconditionRule) -> r.conditionName == conditionName && r.serviceName == serviceName && r.toolName == toolName
        );
        if (maybeExisting.isPresent()) {
            rules = rules.without(maybeExisting.getOrFail());
        };
        info("[PreconditionPolicy] Removed rule: " + serviceName + "." + toolName + " for condition " + conditionName);
    };

    /**
     * Get all precondition rules.
     */
    @api
    permission[pAdmin] getRules() returns List<PreconditionRule> | active {
        return rules;
    };

    // ========================================================================
    // Admin: statistics
    // ========================================================================

    /**
     * Get summary statistics.
     */
    @api
    permission[pAdmin] getStatistics() returns Text | active {
        return "evaluations=" + totalEvaluations.toText()
            + ",denied=" + totalDenied.toText()
            + ",conditions=" + conditions.size().toText()
            + ",rules=" + rules.size().toText();
    };
}
