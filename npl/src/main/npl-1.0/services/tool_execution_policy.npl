package services

use registry.ServiceRegistry;

/**
 * Struct to track approved requests for validation.
 * @param reqService Target service (e.g., "google_gmail")
 * @param reqOperation Operation to perform (e.g., "send_email")
 * @param reqStatus Status: "approved", "validated", "completed", "failed"
 * @param reqCreatedAt Timestamp when request was approved
 */
struct ApprovedRequest {
    reqService: Text,
    reqOperation: Text,
    reqStatus: Text,
    reqCreatedAt: DateTime
};

/**
 * ToolExecutionPolicy - Central policy enforcement for all tool executions.
 * 
 * Flow:
 * 1. Gateway (as pAgent) calls checkAndApprove() - validates policy, returns requestId
 * 2. Executor (as pExecutor) calls validateForExecution() - defense-in-depth check
 * 3. Executor (as pExecutor) calls reportCompletion() - audit trail
 * 
 * Separation of concerns:
 * - pAgent: Gateway/AI agent that requests tool execution
 * - pExecutor: Executor service that validates and reports completion
 * - pAdmin: Administrator who can suspend policy
 * 
 * @party pAdmin Organization administrator
 * @party pAgent AI agent / Gateway making requests
 * @party pExecutor Executor service for validation and audit
 * @param registry ServiceRegistry for service-level checks
 * @param policyTenantId Tenant identifier for this policy instance
 * @param policyGatewayUrl URL of the Gateway for context fetching
 */
@api
protocol[pAdmin, pAgent, pExecutor] ToolExecutionPolicy(
    var registry: ServiceRegistry,
    var policyTenantId: Text,
    var policyGatewayUrl: Text
) {
    initial state ready;
    final state suspended;
    
    private var requestCounter: Number = 0;
    
    private var approvedRequests: Map<Text, ApprovedRequest> = mapOf<Text, ApprovedRequest>();
    
    /**
     * Admin suspends all tool execution.
     */
    @api
    permission[pAdmin] suspendPolicy() | ready {
        become suspended;
    };
    
    /**
     * Agent/Gateway requests tool execution.
     * Returns request ID for tracking.
     * 
     * @param serviceName Target service (e.g., "google_gmail")
     * @param operationName Operation to perform (e.g., "send_email")
     * @param requestMetadata JSON metadata for policy decision (not the body)
     * @param gatewayCallbackUrl URL where Executor sends result
     * @return Request ID if approved
     */
    @api
    permission[pAgent] checkAndApprove(
        serviceName: Text,
        operationName: Text,
        requestMetadata: Text,
        gatewayCallbackUrl: Text
    ) returns Text | ready {
        // Check if service is enabled
        var services = registry.enabledServices;
        var isEnabled = services.contains(serviceName);
        require(isEnabled, "Service is disabled by administrator");
        
        // Generate unique request ID
        requestCounter = requestCounter + 1;
        var newRequestId = policyTenantId + "-" + requestCounter.toText();
        
        // Store approved request for later validation
        var approvedReq = ApprovedRequest(
            reqService = serviceName,
            reqOperation = operationName,
            reqStatus = "approved",
            reqCreatedAt = now()
        );
        approvedRequests = approvedRequests.with(newRequestId, approvedReq);
        
        info("[ToolExecutionPolicy] Request approved: " + newRequestId);
        
        return newRequestId;
    };
    
    /**
     * Executor validates that request was approved (defense in depth).
     * Called by Executor before fetching context and executing.
     * 
     * @param reqId Request ID to validate
     * @param expectedService Expected service name
     * @param expectedOperation Expected operation name
     * @return true if request is valid and approved
     */
    @api
    permission[pExecutor] validateForExecution(
        reqId: Text,
        expectedService: Text,
        expectedOperation: Text
    ) returns Boolean | ready {
        // Look up the request
        var maybeRequest = approvedRequests.getOrNone(reqId);
        
        if (maybeRequest.isPresent()) {
            var req = maybeRequest.getOrFail();
            
            // Verify service and operation match
            var serviceMatch = req.reqService == expectedService;
            var operationMatch = req.reqOperation == expectedOperation;
            var isApproved = req.reqStatus == "approved";
            
            if (serviceMatch && operationMatch && isApproved) {
                // Update status to validated
                var updatedReq = ApprovedRequest(
                    reqService = req.reqService,
                    reqOperation = req.reqOperation,
                    reqStatus = "validated",
                    reqCreatedAt = req.reqCreatedAt
                );
                approvedRequests = approvedRequests.with(reqId, updatedReq);
                
                info("[ToolExecutionPolicy] Request validated: " + reqId);
                return true;
            } else {
                info("[ToolExecutionPolicy] Validation failed - mismatch or wrong status");
                return false;
            };
        } else {
            info("[ToolExecutionPolicy] Validation failed - request not found: " + reqId);
            return false;
        };
    };
    
    /**
     * Executor reports completion (audit trail).
     * Called after execution completes (success or failure).
     * 
     * @param reqId Request ID
     * @param wasSuccessful Whether execution succeeded
     * @param failureMessage Error message if failed (empty if successful)
     * @param execDurationMs Execution duration in milliseconds
     */
    @api
    permission[pExecutor] reportCompletion(
        reqId: Text,
        wasSuccessful: Boolean,
        failureMessage: Text,
        execDurationMs: Number
    ) | ready {
        var maybeRequest = approvedRequests.getOrNone(reqId);
        
        if (maybeRequest.isPresent()) {
            var req = maybeRequest.getOrFail();
            var newStatus = if (wasSuccessful) { "completed" } else { "failed" };
            
            var updatedReq = ApprovedRequest(
                reqService = req.reqService,
                reqOperation = req.reqOperation,
                reqStatus = newStatus,
                reqCreatedAt = req.reqCreatedAt
            );
            approvedRequests = approvedRequests.with(reqId, updatedReq);
            
            if (wasSuccessful) {
                info("[ToolExecutionPolicy] Request completed: " + reqId + " in " + execDurationMs.toText() + "ms");
            } else {
                info("[ToolExecutionPolicy] Request failed: " + reqId + " - " + failureMessage);
            };
        } else {
            info("[ToolExecutionPolicy] Cannot report completion - request not found: " + reqId);
        };
    };
    
    /**
     * Get request count.
     * @return Number of requests processed
     */
    @api
    permission[pAdmin | pAgent | pExecutor] getRequestCount() returns Number | ready, suspended {
        return requestCounter;
    };
    
    /**
     * Get request status (for debugging/admin).
     * @param reqId Request ID to look up
     * @return Status text or "not_found"
     */
    @api
    permission[pAdmin | pAgent | pExecutor] getRequestStatus(reqId: Text) returns Text | ready, suspended {
        var maybeRequest = approvedRequests.getOrNone(reqId);
        if (maybeRequest.isPresent()) {
            return maybeRequest.getOrFail().reqStatus;
        } else {
            return "not_found";
        };
    };
}
