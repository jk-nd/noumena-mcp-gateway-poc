package services

/**
 * Struct to represent a tool access rule.
 * @param toolAccessName The tool name (e.g., "search", "send_message")
 * @param toolAccessAllowed Whether access is allowed
 */
struct ToolAccessRule {
    toolAccessName: Text,
    toolAccessAllowed: Boolean
};

/**
 * Per-service tool access policy.
 *
 * Each upstream MCP service gets its own ToolPolicy instance at runtime.
 * The admin creates instances via the TUI during NPL bootstrap.
 *
 * Features:
 *   - Per-tool enable/disable (granular control)
 *   - Default-deny: tools must be explicitly enabled
 *   - Audit trail: request counting
 *
 * Future enhancements (deferred to MVP):
 *   - Per-user/per-agent access rules
 *   - Rate limiting
 *   - Credential mapping governance
 *
 * @party pAdmin Organization administrator
 * @party pAgent AI agent / Gateway making requests
 * @param policyServiceName The upstream service this policy governs (e.g., "duckduckgo")
 */
@api
protocol[pAdmin, pAgent] ToolPolicy(
    var policyServiceName: Text
) {
    initial state active;
    final state suspended;

    private var enabledTools: Set<Text> = setOf<Text>();
    private var requestCounter: Number = 0;

    /**
     * Enable a tool for this service.
     * @param toolName The tool to enable (e.g., "search")
     */
    @api
    permission[pAdmin] enableTool(toolName: Text) | active {
        enabledTools = enabledTools.with(toolName);
        info("[ToolPolicy:" + policyServiceName + "] Enabled tool: " + toolName);
    };

    /**
     * Disable a tool for this service.
     * @param toolName The tool to disable
     */
    @api
    permission[pAdmin] disableTool(toolName: Text) | active {
        enabledTools = enabledTools.without(toolName);
        info("[ToolPolicy:" + policyServiceName + "] Disabled tool: " + toolName);
    };

    /**
     * Enable all tools at once.
     * @param toolNames List of tool names to enable
     */
    @api
    permission[pAdmin] enableAllTools(toolNames: List<Text>) | active {
        for (toolName in toolNames) {
            enabledTools = enabledTools.with(toolName);
        };
        info("[ToolPolicy:" + policyServiceName + "] Enabled " + toolNames.size().toText() + " tools");
    };

    /**
     * Check if a tool call is allowed.
     * Called by the Gateway (as pAgent) before forwarding to upstream.
     *
     * @param toolName The tool being called
     * @param callerIdentity The user/agent identity (for future per-user rules)
     * @return true if access is allowed
     */
    @api
    permission[pAgent] checkAccess(
        toolName: Text,
        callerIdentity: Text
    ) returns Boolean | active {
        requestCounter = requestCounter + 1;

        var allowed = enabledTools.contains(toolName);

        if (allowed) {
            info("[ToolPolicy:" + policyServiceName + "] ALLOWED: " + toolName + " (caller: " + callerIdentity + ")");
        } else {
            info("[ToolPolicy:" + policyServiceName + "] DENIED: " + toolName + " (caller: " + callerIdentity + ")");
        };

        return allowed;
    };

    /**
     * Get all enabled tools for this service.
     * @return Set of enabled tool names
     */
    @api
    permission[pAdmin | pAgent] getEnabledTools() returns Set<Text> | active, suspended {
        return enabledTools;
    };

    /**
     * Get request count for monitoring.
     * @return Total number of policy checks
     */
    @api
    permission[pAdmin | pAgent] getRequestCount() returns Number | active, suspended {
        return requestCounter;
    };

    /**
     * Suspend this policy (emergency kill switch).
     * All tool calls for this service will be denied.
     */
    @api
    permission[pAdmin] suspendPolicy() | active {
        become suspended;
    };
};
