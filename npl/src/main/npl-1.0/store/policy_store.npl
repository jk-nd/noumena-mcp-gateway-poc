package store

/**
 * Entry for a registered MCP service in the catalog.
 */
struct ServiceEntry {
    serviceName: Text,
    enabled: Boolean,
    enabledTools: Set<Text>,
    suspended: Boolean,
    metadata: Map<Text, Text>
};

/**
 * Per-user grant entry: which tools are allowed on which service.
 * allowedTools may contain "*" for wildcard (all tools).
 */
struct GrantEntry {
    serviceName: Text,
    allowedTools: Set<Text>
};

/**
 * Routing entry for contextual (Layer 2) policy evaluation.
 * Points to an NPL protocol instance that implements evaluate().
 */
struct ContextualRoute {
    policyProtocol: Text,
    instanceId: Text,
    endpoint: Text
};

/**
 * A group of contextual routes evaluated together for a service+tool.
 * mode: "single" (legacy), "and" (all must allow), "or" (first allow wins)
 */
struct RouteGroup {
    mode: Text,
    routes: List<ContextualRoute>
};

/**
 * Complete policy data returned by getPolicyData().
 * Bundle server reads everything in one call.
 */
struct PolicyData {
    services: Map<Text, ServiceEntry>,
    grants: Map<Text, List<GrantEntry>>,
    revokedSubjects: Set<Text>,
    contextualRoutes: Map<Text, Map<Text, RouteGroup>>,
    securityPolicy: Text
};

/**
 * PolicyStore — unified singleton for all MCP Gateway policy data.
 *
 * Replaces ServiceRegistry, ToolPolicy, UserToolAccess, and UserRegistry
 * with a single protocol. Bundle server reads everything in ONE getPolicyData()
 * call (2 HTTP calls total: list singleton + getPolicyData).
 *
 * Catalog: services + their enabled tools (organization-wide)
 * Grants: per-user tool access (user-level)
 * Contextual routes: Layer 2 policy routing table (Phase 3)
 *
 * @party pAdmin  Organization administrator (manages catalog + grants)
 * @party pGateway Gateway system service (reads policy data at runtime)
 */
@api
protocol[pAdmin, pGateway] PolicyStore() {
    initial state active;

    // --- Catalog: services + tools ---
    private var services: Map<Text, ServiceEntry> = mapOf<Text, ServiceEntry>();

    // --- Grants: per-user access ---
    private var grants: Map<Text, List<GrantEntry>> = mapOf<Text, List<GrantEntry>>();

    // --- Emergency revocation ---
    private var revokedSubjects: Set<Text> = setOf<Text>();

    // --- Contextual routing table (Layer 2) ---
    private var contextualRoutes: Map<Text, Map<Text, RouteGroup>> = mapOf<Text, Map<Text, RouteGroup>>();

    // --- Security policy (JSON-serialized mcp-security.yaml) ---
    private var securityPolicy: Text = "";

    // ========================================================================
    // Catalog management
    // ========================================================================

    /**
     * Register a new service in the catalog (disabled by default).
     */
    @api
    permission[pAdmin] registerService(serviceName: Text) | active {
        require(!services.getOrNone(serviceName).isPresent(), "Service already registered");
        var entry = ServiceEntry(
            serviceName = serviceName,
            enabled = false,
            enabledTools = setOf<Text>(),
            suspended = false,
            metadata = mapOf<Text, Text>()
        );
        services = services.with(serviceName, entry);
        info("[PolicyStore] Registered service: " + serviceName);
    };

    /**
     * Enable a service (makes it available for tool calls).
     */
    @api
    permission[pAdmin] enableService(serviceName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = true,
            enabledTools = entry.enabledTools,
            suspended = entry.suspended,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Enabled service: " + serviceName);
    };

    /**
     * Disable a service (blocks all tool calls).
     */
    @api
    permission[pAdmin] disableService(serviceName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = false,
            enabledTools = entry.enabledTools,
            suspended = entry.suspended,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Disabled service: " + serviceName);
    };

    /**
     * Enable a tool for a service.
     */
    @api
    permission[pAdmin] enableTool(serviceName: Text, toolName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = entry.enabled,
            enabledTools = entry.enabledTools.with(toolName),
            suspended = entry.suspended,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Enabled tool: " + serviceName + "." + toolName);
    };

    /**
     * Disable a tool for a service.
     */
    @api
    permission[pAdmin] disableTool(serviceName: Text, toolName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = entry.enabled,
            enabledTools = entry.enabledTools.without(toolName),
            suspended = entry.suspended,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Disabled tool: " + serviceName + "." + toolName);
    };

    /**
     * Suspend a service (emergency kill switch — blocks all tool calls).
     */
    @api
    permission[pAdmin] suspendService(serviceName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = entry.enabled,
            enabledTools = entry.enabledTools,
            suspended = true,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Suspended service: " + serviceName);
    };

    /**
     * Resume a suspended service.
     */
    @api
    permission[pAdmin] resumeService(serviceName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = entry.enabled,
            enabledTools = entry.enabledTools,
            suspended = false,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Resumed service: " + serviceName);
    };

    // ========================================================================
    // Per-user grant management
    // ========================================================================

    /**
     * Grant a specific tool on a service to a user.
     */
    @api
    permission[pAdmin] grantTool(subjectId: Text, serviceName: Text, toolName: Text) | active {
        var maybeGrants = grants.getOrNone(subjectId);
        var userGrants = if (maybeGrants.isPresent()) {
            maybeGrants.getOrFail();
        } else {
            listOf<GrantEntry>();
        };
        var existing = userGrants.findFirstOrNone(function(g: GrantEntry) -> g.serviceName == serviceName);

        if (existing.isPresent()) {
            var entry = existing.getOrFail();
            var updated = GrantEntry(serviceName = serviceName, allowedTools = entry.allowedTools.with(toolName));
            userGrants = userGrants.without(entry).with(updated);
        } else {
            userGrants = userGrants.with(GrantEntry(serviceName = serviceName, allowedTools = setOf(toolName)));
        };

        grants = grants.with(subjectId, userGrants);
        info("[PolicyStore] Granted " + subjectId + " -> " + serviceName + "." + toolName);
    };

    /**
     * Grant wildcard access to all tools on a service.
     */
    @api
    permission[pAdmin] grantAllToolsForService(subjectId: Text, serviceName: Text) | active {
        var maybeGrants = grants.getOrNone(subjectId);
        var userGrants = if (maybeGrants.isPresent()) {
            maybeGrants.getOrFail();
        } else {
            listOf<GrantEntry>();
        };
        var existing = userGrants.findFirstOrNone(function(g: GrantEntry) -> g.serviceName == serviceName);

        var wildcardEntry = GrantEntry(serviceName = serviceName, allowedTools = setOf("*"));

        if (existing.isPresent()) {
            var entry = existing.getOrFail();
            userGrants = userGrants.without(entry).with(wildcardEntry);
        } else {
            userGrants = userGrants.with(wildcardEntry);
        };

        grants = grants.with(subjectId, userGrants);
        info("[PolicyStore] Granted " + subjectId + " -> " + serviceName + ".* (all tools)");
    };

    /**
     * Revoke a specific tool on a service from a user.
     */
    @api
    permission[pAdmin] revokeTool(subjectId: Text, serviceName: Text, toolName: Text) | active {
        var maybeGrants = grants.getOrNone(subjectId);
        var userGrants = if (maybeGrants.isPresent()) {
            maybeGrants.getOrFail();
        } else {
            listOf<GrantEntry>();
        };
        var existing = userGrants.findFirstOrNone(function(g: GrantEntry) -> g.serviceName == serviceName);

        if (existing.isPresent()) {
            var entry = existing.getOrFail();
            var updatedTools = entry.allowedTools.without(toolName);
            if (updatedTools.size() == 0) {
                userGrants = userGrants.without(entry);
            } else {
                userGrants = userGrants.without(entry).with(GrantEntry(serviceName = serviceName, allowedTools = updatedTools));
            };
            grants = grants.with(subjectId, userGrants);
        };

        info("[PolicyStore] Revoked " + subjectId + " -> " + serviceName + "." + toolName);
    };

    /**
     * Revoke all access to a service from a user.
     */
    @api
    permission[pAdmin] revokeServiceAccess(subjectId: Text, serviceName: Text) | active {
        var maybeGrants = grants.getOrNone(subjectId);
        var userGrants = if (maybeGrants.isPresent()) {
            maybeGrants.getOrFail();
        } else {
            listOf<GrantEntry>();
        };
        var existing = userGrants.findFirstOrNone(function(g: GrantEntry) -> g.serviceName == serviceName);

        if (existing.isPresent()) {
            userGrants = userGrants.without(existing.getOrFail());
            grants = grants.with(subjectId, userGrants);
        };

        info("[PolicyStore] Revoked " + subjectId + " -> " + serviceName + " (all)");
    };

    /**
     * Emergency: revoke ALL access for a subject (fail-closed).
     */
    @api
    permission[pAdmin] revokeSubject(subjectId: Text) | active {
        revokedSubjects = revokedSubjects.with(subjectId);
        info("[PolicyStore] REVOKED subject: " + subjectId);
    };

    /**
     * Reinstate a previously revoked subject.
     */
    @api
    permission[pAdmin] reinstateSubject(subjectId: Text) | active {
        revokedSubjects = revokedSubjects.without(subjectId);
        info("[PolicyStore] Reinstated subject: " + subjectId);
    };

    // ========================================================================
    // Contextual routing (Layer 2)
    // ========================================================================

    /**
     * Register a contextual policy route for a service+tool combination.
     * Creates a single-route RouteGroup. Use toolName="*" for service-wide routes.
     * If a group already exists for this service+tool, it is replaced.
     */
    @api
    permission[pAdmin] registerRoute(
        serviceName: Text,
        toolName: Text,
        routeProtocol: Text,
        instanceId: Text,
        endpoint: Text
    ) | active {
        var maybeRoutes = contextualRoutes.getOrNone(serviceName);
        var serviceRoutes = if (maybeRoutes.isPresent()) {
            maybeRoutes.getOrFail();
        } else {
            mapOf<Text, RouteGroup>();
        };
        var route = ContextualRoute(policyProtocol = routeProtocol, instanceId = instanceId, endpoint = endpoint);
        var group = RouteGroup(mode = "single", routes = listOf(route));
        serviceRoutes = serviceRoutes.with(toolName, group);
        contextualRoutes = contextualRoutes.with(serviceName, serviceRoutes);
        info("[PolicyStore] Registered route: " + serviceName + "." + toolName);
    };

    /**
     * Remove all contextual policy routes for a service+tool.
     */
    @api
    permission[pAdmin] removeRoute(serviceName: Text, toolName: Text) | active {
        var maybeRoutes = contextualRoutes.getOrNone(serviceName);
        if (maybeRoutes.isPresent()) {
            var serviceRoutes = maybeRoutes.getOrFail();
            serviceRoutes = serviceRoutes.without(toolName);
            if (serviceRoutes.size() == 0) {
                contextualRoutes = contextualRoutes.without(serviceName);
            } else {
                contextualRoutes = contextualRoutes.with(serviceName, serviceRoutes);
            };
        };
        info("[PolicyStore] Removed route: " + serviceName + "." + toolName);
    };

    /**
     * Add a route to an existing RouteGroup for a service+tool.
     * If no group exists, creates a new "and" group with this route.
     */
    @api
    permission[pAdmin] addRouteToGroup(
        serviceName: Text,
        toolName: Text,
        routeProtocol: Text,
        instanceId: Text,
        endpoint: Text
    ) | active {
        var maybeRoutes = contextualRoutes.getOrNone(serviceName);
        var serviceRoutes = if (maybeRoutes.isPresent()) {
            maybeRoutes.getOrFail()
        } else {
            mapOf<Text, RouteGroup>()
        };
        var route = ContextualRoute(policyProtocol = routeProtocol, instanceId = instanceId, endpoint = endpoint);

        var maybeGroup = serviceRoutes.getOrNone(toolName);
        var group = if (maybeGroup.isPresent()) {
            var existing = maybeGroup.getOrFail();
            var newMode = if (existing.mode == "single") { "and" } else { existing.mode };
            RouteGroup(mode = newMode, routes = existing.routes.with(route));
        } else {
            RouteGroup(mode = "and", routes = listOf(route));
        };

        serviceRoutes = serviceRoutes.with(toolName, group);
        contextualRoutes = contextualRoutes.with(serviceName, serviceRoutes);
        info("[PolicyStore] Added route to group: " + serviceName + "." + toolName + " (" + routeProtocol + ")");
    };

    /**
     * Remove a route from a RouteGroup by protocol name.
     * If the group becomes empty, removes the entire group.
     */
    @api
    permission[pAdmin] removeRouteFromGroup(
        serviceName: Text,
        toolName: Text,
        routeProtocol: Text
    ) | active {
        var maybeRoutes = contextualRoutes.getOrNone(serviceName);
        if (maybeRoutes.isPresent()) {
            var serviceRoutes = maybeRoutes.getOrFail();
            var maybeGroup = serviceRoutes.getOrNone(toolName);
            if (maybeGroup.isPresent()) {
                var existing = maybeGroup.getOrFail();
                var filtered = existing.routes.filter(
                    function(r: ContextualRoute) -> r.policyProtocol != routeProtocol
                );
                if (filtered.size() == 0) {
                    serviceRoutes = serviceRoutes.without(toolName);
                    if (serviceRoutes.size() == 0) {
                        contextualRoutes = contextualRoutes.without(serviceName);
                    } else {
                        contextualRoutes = contextualRoutes.with(serviceName, serviceRoutes);
                    };
                } else {
                    var updatedGroup = RouteGroup(mode = existing.mode, routes = filtered);
                    serviceRoutes = serviceRoutes.with(toolName, updatedGroup);
                    contextualRoutes = contextualRoutes.with(serviceName, serviceRoutes);
                };
            };
        };
        info("[PolicyStore] Removed route from group: " + serviceName + "." + toolName + " (" + routeProtocol + ")");
    };

    /**
     * Set the evaluation mode for a RouteGroup: "and" or "or".
     */
    @api
    permission[pAdmin] setRouteGroupMode(serviceName: Text, toolName: Text, mode: Text) | active {
        require(mode == "and" || mode == "or", "Mode must be 'and' or 'or'");
        var maybeRoutes = contextualRoutes.getOrNone(serviceName);
        require(maybeRoutes.isPresent(), "No routes for service");
        var serviceRoutes = maybeRoutes.getOrFail();
        var maybeGroup = serviceRoutes.getOrNone(toolName);
        require(maybeGroup.isPresent(), "No route group for tool");
        var existing = maybeGroup.getOrFail();
        var updated = RouteGroup(mode = mode, routes = existing.routes);
        serviceRoutes = serviceRoutes.with(toolName, updated);
        contextualRoutes = contextualRoutes.with(serviceName, serviceRoutes);
        info("[PolicyStore] Set route group mode: " + serviceName + "." + toolName + " -> " + mode);
    };

    /**
     * Set a metadata key on a service entry.
     * Used by TUI to store operational config (displayName, type, command, etc.)
     */
    @api
    permission[pAdmin] setServiceMetadata(serviceName: Text, key: Text, value: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = entry.enabled,
            enabledTools = entry.enabledTools,
            suspended = entry.suspended,
            metadata = entry.metadata.with(key, value)
        );
        services = services.with(serviceName, updated);
    };

    /**
     * Remove a service entirely from the catalog.
     */
    @api
    permission[pAdmin] removeService(serviceName: Text) | active {
        require(services.getOrNone(serviceName).isPresent(), "Service not found");
        services = services.without(serviceName);
    };

    // ========================================================================
    // Security policy management
    // ========================================================================

    /**
     * Set the security policy (JSON-serialized mcp-security.yaml).
     * Applied via CLI: parse YAML → validate → merge profiles → serialize → set.
     */
    @api
    permission[pAdmin] setSecurityPolicy(policyJson: Text) | active {
        securityPolicy = policyJson;
        info("[PolicyStore] Security policy updated (" + policyJson.length().toText() + " bytes)");
    };

    /**
     * Clear the security policy (revert to no security policy).
     */
    @api
    permission[pAdmin] clearSecurityPolicy() | active {
        securityPolicy = "";
        info("[PolicyStore] Security policy cleared");
    };

    // ========================================================================
    // Bundle server reads everything in ONE call
    // ========================================================================

    /**
     * Get all policy data in a single call.
     * Bundle server calls this once per rebuild (2 HTTP calls total).
     */
    @api
    permission[pAdmin | pGateway] getPolicyData() returns PolicyData | active {
        return PolicyData(
            services = services,
            grants = grants,
            revokedSubjects = revokedSubjects,
            contextualRoutes = contextualRoutes,
            securityPolicy = securityPolicy
        );
    };
}
