package policy

/**
 * Entry for a registered MCP service in the catalog.
 */
struct ServiceEntry {
    serviceName: Text,
    enabled: Boolean,
    enabledTools: Set<Text>,
    suspended: Boolean,
    metadata: Map<Text, Text>
};

/**
 * Per-user grant entry: which tools are allowed on which service.
 * allowedTools may contain "*" for wildcard (all tools).
 */
struct GrantEntry {
    serviceName: Text,
    allowedTools: Set<Text>
};

/**
 * Routing entry for contextual (Layer 2) policy evaluation.
 * Points to an NPL protocol instance that implements evaluate().
 */
struct ContextualRoute {
    policyProtocol: Text,
    instanceId: Text,
    endpoint: Text
};

/**
 * Complete policy data returned by getPolicyData().
 * Bundle server reads everything in one call.
 */
struct PolicyData {
    services: Map<Text, ServiceEntry>,
    grants: Map<Text, List<GrantEntry>>,
    revokedSubjects: Set<Text>,
    contextualRoutes: Map<Text, Map<Text, ContextualRoute>>
};

/**
 * PolicyStore — unified singleton for all MCP Gateway policy data.
 *
 * Replaces ServiceRegistry, ToolPolicy, UserToolAccess, and UserRegistry
 * with a single protocol. Bundle server reads everything in ONE getPolicyData()
 * call (2 HTTP calls total: list singleton + getPolicyData).
 *
 * Catalog: services + their enabled tools (organization-wide)
 * Grants: per-user tool access (user-level)
 * Contextual routes: Layer 2 policy routing table (Phase 3)
 *
 * @party pAdmin  Organization administrator (manages catalog + grants)
 * @party pGateway Gateway system service (reads policy data at runtime)
 */
@api
protocol[pAdmin, pGateway] PolicyStore() {
    initial state active;

    // --- Catalog: services + tools ---
    private var services: Map<Text, ServiceEntry> = mapOf<Text, ServiceEntry>();

    // --- Grants: per-user access ---
    private var grants: Map<Text, List<GrantEntry>> = mapOf<Text, List<GrantEntry>>();

    // --- Emergency revocation ---
    private var revokedSubjects: Set<Text> = setOf<Text>();

    // --- Contextual routing table (Phase 3) ---
    private var contextualRoutes: Map<Text, Map<Text, ContextualRoute>> = mapOf<Text, Map<Text, ContextualRoute>>();

    // ========================================================================
    // Catalog management
    // ========================================================================

    /**
     * Register a new service in the catalog (disabled by default).
     */
    @api
    permission[pAdmin] registerService(serviceName: Text) | active {
        require(!services.getOrNone(serviceName).isPresent(), "Service already registered");
        var entry = ServiceEntry(
            serviceName = serviceName,
            enabled = false,
            enabledTools = setOf<Text>(),
            suspended = false,
            metadata = mapOf<Text, Text>()
        );
        services = services.with(serviceName, entry);
        info("[PolicyStore] Registered service: " + serviceName);
    };

    /**
     * Enable a service (makes it available for tool calls).
     */
    @api
    permission[pAdmin] enableService(serviceName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = true,
            enabledTools = entry.enabledTools,
            suspended = entry.suspended,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Enabled service: " + serviceName);
    };

    /**
     * Disable a service (blocks all tool calls).
     */
    @api
    permission[pAdmin] disableService(serviceName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = false,
            enabledTools = entry.enabledTools,
            suspended = entry.suspended,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Disabled service: " + serviceName);
    };

    /**
     * Enable a tool for a service.
     */
    @api
    permission[pAdmin] enableTool(serviceName: Text, toolName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = entry.enabled,
            enabledTools = entry.enabledTools.with(toolName),
            suspended = entry.suspended,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Enabled tool: " + serviceName + "." + toolName);
    };

    /**
     * Disable a tool for a service.
     */
    @api
    permission[pAdmin] disableTool(serviceName: Text, toolName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = entry.enabled,
            enabledTools = entry.enabledTools.without(toolName),
            suspended = entry.suspended,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Disabled tool: " + serviceName + "." + toolName);
    };

    /**
     * Suspend a service (emergency kill switch — blocks all tool calls).
     */
    @api
    permission[pAdmin] suspendService(serviceName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = entry.enabled,
            enabledTools = entry.enabledTools,
            suspended = true,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Suspended service: " + serviceName);
    };

    /**
     * Resume a suspended service.
     */
    @api
    permission[pAdmin] resumeService(serviceName: Text) | active {
        var maybeEntry = services.getOrNone(serviceName);
        require(maybeEntry.isPresent(), "Service not found");
        var entry = maybeEntry.getOrFail();
        var updated = ServiceEntry(
            serviceName = entry.serviceName,
            enabled = entry.enabled,
            enabledTools = entry.enabledTools,
            suspended = false,
            metadata = entry.metadata
        );
        services = services.with(serviceName, updated);
        info("[PolicyStore] Resumed service: " + serviceName);
    };

    // ========================================================================
    // Per-user grant management
    // ========================================================================

    /**
     * Grant a specific tool on a service to a user.
     */
    @api
    permission[pAdmin] grantTool(subjectId: Text, serviceName: Text, toolName: Text) | active {
        var maybeGrants = grants.getOrNone(subjectId);
        var userGrants = if (maybeGrants.isPresent()) {
            maybeGrants.getOrFail()
        } else {
            listOf<GrantEntry>()
        };
        var existing = userGrants.findFirstOrNone(function(g: GrantEntry) -> g.serviceName == serviceName);

        if (existing.isPresent()) {
            var entry = existing.getOrFail();
            var updated = GrantEntry(serviceName = serviceName, allowedTools = entry.allowedTools.with(toolName));
            userGrants = userGrants.without(entry).with(updated);
        } else {
            userGrants = userGrants.with(GrantEntry(serviceName = serviceName, allowedTools = setOf(toolName)));
        };

        grants = grants.with(subjectId, userGrants);
        info("[PolicyStore] Granted " + subjectId + " -> " + serviceName + "." + toolName);
    };

    /**
     * Grant wildcard access to all tools on a service.
     */
    @api
    permission[pAdmin] grantAllToolsForService(subjectId: Text, serviceName: Text) | active {
        var maybeGrants = grants.getOrNone(subjectId);
        var userGrants = if (maybeGrants.isPresent()) {
            maybeGrants.getOrFail()
        } else {
            listOf<GrantEntry>()
        };
        var existing = userGrants.findFirstOrNone(function(g: GrantEntry) -> g.serviceName == serviceName);

        var wildcardEntry = GrantEntry(serviceName = serviceName, allowedTools = setOf("*"));

        if (existing.isPresent()) {
            var entry = existing.getOrFail();
            userGrants = userGrants.without(entry).with(wildcardEntry);
        } else {
            userGrants = userGrants.with(wildcardEntry);
        };

        grants = grants.with(subjectId, userGrants);
        info("[PolicyStore] Granted " + subjectId + " -> " + serviceName + ".* (all tools)");
    };

    /**
     * Revoke a specific tool on a service from a user.
     */
    @api
    permission[pAdmin] revokeTool(subjectId: Text, serviceName: Text, toolName: Text) | active {
        var maybeGrants = grants.getOrNone(subjectId);
        var userGrants = if (maybeGrants.isPresent()) {
            maybeGrants.getOrFail()
        } else {
            listOf<GrantEntry>()
        };
        var existing = userGrants.findFirstOrNone(function(g: GrantEntry) -> g.serviceName == serviceName);

        if (existing.isPresent()) {
            var entry = existing.getOrFail();
            var updatedTools = entry.allowedTools.without(toolName);
            if (updatedTools.size() == 0) {
                userGrants = userGrants.without(entry);
            } else {
                userGrants = userGrants.without(entry).with(GrantEntry(serviceName = serviceName, allowedTools = updatedTools));
            };
            grants = grants.with(subjectId, userGrants);
        };

        info("[PolicyStore] Revoked " + subjectId + " -> " + serviceName + "." + toolName);
    };

    /**
     * Revoke all access to a service from a user.
     */
    @api
    permission[pAdmin] revokeServiceAccess(subjectId: Text, serviceName: Text) | active {
        var maybeGrants = grants.getOrNone(subjectId);
        var userGrants = if (maybeGrants.isPresent()) {
            maybeGrants.getOrFail()
        } else {
            listOf<GrantEntry>()
        };
        var existing = userGrants.findFirstOrNone(function(g: GrantEntry) -> g.serviceName == serviceName);

        if (existing.isPresent()) {
            userGrants = userGrants.without(existing.getOrFail());
            grants = grants.with(subjectId, userGrants);
        };

        info("[PolicyStore] Revoked " + subjectId + " -> " + serviceName + " (all)");
    };

    /**
     * Emergency: revoke ALL access for a subject (fail-closed).
     */
    @api
    permission[pAdmin] revokeSubject(subjectId: Text) | active {
        revokedSubjects = revokedSubjects.with(subjectId);
        info("[PolicyStore] REVOKED subject: " + subjectId);
    };

    /**
     * Reinstate a previously revoked subject.
     */
    @api
    permission[pAdmin] reinstateSubject(subjectId: Text) | active {
        revokedSubjects = revokedSubjects.without(subjectId);
        info("[PolicyStore] Reinstated subject: " + subjectId);
    };

    // ========================================================================
    // Contextual routing (Phase 3)
    // ========================================================================

    /**
     * Register a contextual policy route for a service+tool combination.
     * Use toolName="*" for service-wide routes.
     */
    @api
    permission[pAdmin] registerRoute(
        serviceName: Text,
        toolName: Text,
        routeProtocol: Text,
        instanceId: Text,
        endpoint: Text
    ) | active {
        var maybeRoutes = contextualRoutes.getOrNone(serviceName);
        var serviceRoutes = if (maybeRoutes.isPresent()) {
            maybeRoutes.getOrFail()
        } else {
            mapOf<Text, ContextualRoute>()
        };
        var route = ContextualRoute(policyProtocol = routeProtocol, instanceId = instanceId, endpoint = endpoint);
        serviceRoutes = serviceRoutes.with(toolName, route);
        contextualRoutes = contextualRoutes.with(serviceName, serviceRoutes);
        info("[PolicyStore] Registered route: " + serviceName + "." + toolName);
    };

    /**
     * Remove a contextual policy route.
     */
    @api
    permission[pAdmin] removeRoute(serviceName: Text, toolName: Text) | active {
        var maybeRoutes = contextualRoutes.getOrNone(serviceName);
        if (maybeRoutes.isPresent()) {
            var serviceRoutes = maybeRoutes.getOrFail();
            serviceRoutes = serviceRoutes.without(toolName);
            if (serviceRoutes.size() == 0) {
                contextualRoutes = contextualRoutes.without(serviceName);
            } else {
                contextualRoutes = contextualRoutes.with(serviceName, serviceRoutes);
            };
        };
        info("[PolicyStore] Removed route: " + serviceName + "." + toolName);
    };

    // ========================================================================
    // Bundle server reads everything in ONE call
    // ========================================================================

    /**
     * Get all policy data in a single call.
     * Bundle server calls this once per rebuild (2 HTTP calls total).
     */
    @api
    permission[pGateway] getPolicyData() returns PolicyData | active {
        return PolicyData(
            services = services,
            grants = grants,
            revokedSubjects = revokedSubjects,
            contextualRoutes = contextualRoutes
        );
    };
}
